---
alwaysApply: true
---


# Regras Cursor para Frontend Next.js (Detallhado)

# Contexto
Projeto frontend em Next.js 14+ com TypeScript, usando Zod, React Hook Form e shadcn/ui. O objetivo é criar um sistema moderno, modular, escalável e com boa UX/UI.

# Padrões Gerais
- Usar **App Router** (`app/`) do Next.js.
- Priorizar **Server Components** para carregamento rápido.
- **Client Components** apenas para interação com formulários ou estados locais.
- **TypeScript estrito** (`strict: true`) e tipagem completa.
- Componentes organizados em `components/`, separando `ui/` de componentes específicos.
- **shadcn/ui** para UI padrão.
- Validar dados com **Zod**.
- Usar **React Hook Form** integrado com Zod.
- Evitar `useEffect` para fetch que pode ser feito via Server Components.
- Tipar sempre o retorno das APIs.

# Estrutura Recomendada
```
app/
  dashboard/
    page.tsx
    layout.tsx
  login/
    page.tsx
components/
  ui/
    button.tsx
    input.tsx
    modal.tsx
    card.tsx
  forms/
    login-form.tsx
lib/
  api.ts
  validators.ts
types/
  index.ts
```

# Formulários com Zod + React Hook Form
- Sempre usar **ZodResolver**.
- Usar **shadcn/ui** (`Form`, `FormField`, `FormItem`, `FormLabel`, `FormControl`, `FormMessage`, `Input`, `Button`) para padronização.

## Exemplo: Formulário de Login
```
"use client";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

const loginSchema = z.object({
  email: z.string().email({ message: "Email inválido" }),
  password: z.string().min(6, { message: "Senha mínima de 6 caracteres" }),
});

type LoginFormValues = z.infer<typeof loginSchema>;

export function LoginForm() {
  const form = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: { email: "", password: "" },
  });

  const onSubmit = (values: LoginFormValues) => {
    console.log("Login:", values);
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input {...field} placeholder="Digite seu email" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="password"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Senha</FormLabel>
              <FormControl>
                <Input type="password" {...field} placeholder="Digite sua senha" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit">Entrar</Button>
      </form>
    </Form>
  );
}
```

# Cards Reutilizáveis
```
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";

export function InfoCard({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <Card className="bg-white dark:bg-gray-800 shadow-md rounded-lg">
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>{children}</CardContent>
    </Card>
  );
}
```

# Modals com shadcn/ui
```
import { Dialog, DialogTrigger, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogClose } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

export function ConfirmModal({ title, description, onConfirm }: { title: string; description: string; onConfirm: () => void }) {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button>Abrir Modal</Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
          <DialogDescription>{description}</DialogDescription>
        </DialogHeader>
        <div className="flex justify-end mt-4 gap-2">
          <Button variant="outline" onClick={() => {}}>Cancelar</Button>
          <Button onClick={onConfirm}>Confirmar</Button>
        </div>
        <DialogClose />
      </DialogContent>
    </Dialog>
  );
}
```

# Uso de Ícones com lucide-react
- Todos os ícones devem vir de **lucide-react**.
- Evitar SVGs inline ou outras bibliotecas.
- Importar ícones de forma específica:
```
import { Home, User, Trash } from "lucide-react";
```
- Usar em componentes do shadcn/ui ou botões, inputs, menus.
- Exemplo de botão com ícone:
```
import { Button } from "@/components/ui/button";
import { Trash } from "lucide-react";

<Button variant="destructive" size="sm">
  <Trash className="mr-2 h-4 w-4" />
  Excluir
</Button>
```
- Manter consistência de tamanho, cor e estilo em todos os ícones.

# API Routes & Server Actions
- Usar Zod para validar entrada e saída.
- Tipar retorno e erros.
```
import { z } from "zod";
import type { NextRequest, NextResponse } from "next/server";

const loginSchema = z.object({ email: z.string().email(), password: z.string() });

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const data = loginSchema.parse(body);
    return NextResponse.json({ success: true, data });
  } catch (err) {
    return NextResponse.json({ success: false, error: err }, { status: 400 });
  }
}
```

# Extras Next.js
- next/image, next/font
- Dynamic imports
- Prefetch automático com Link
- Server Components para fetch
- Client Components apenas para interação

# Observações Finais
- Priorizar Server Components.
- Validar todos os dados com Zod.
- Seguir rigorosamente shadcn/ui.
- Componentes reutilizáveis.
- Formulários sempre com React Hook Form + Zod.
- Ícones sempre com lucide-react.

# Regras Cursor para Frontend Next.js (Detallhado)

# Contexto
Projeto frontend em Next.js 14+ com TypeScript, usando Zod, React Hook Form e shadcn/ui. O objetivo é criar um sistema moderno, modular, escalável e com boa UX/UI.

# Padrões Gerais
- Usar **App Router** (`app/`) do Next.js.
- Priorizar **Server Components** para carregamento rápido.
- **Client Components** apenas para interação com formulários ou estados locais.
- **TypeScript estrito** (`strict: true`) e tipagem completa.
- Componentes organizados em `components/`, separando `ui/` de componentes específicos.
- **shadcn/ui** para UI padrão.
- Validar dados com **Zod**.
- Usar **React Hook Form** integrado com Zod.
- Evitar `useEffect` para fetch que pode ser feito via Server Components.
- Tipar sempre o retorno das APIs.

# Estrutura Recomendada
```
app/
  dashboard/
    page.tsx
    layout.tsx
  login/
    page.tsx
components/
  ui/
    button.tsx
    input.tsx
    modal.tsx
    card.tsx
  forms/
    login-form.tsx
lib/
  api.ts
  validators.ts
types/
  index.ts
```

# Formulários com Zod + React Hook Form
- Sempre usar **ZodResolver**.
- Usar **shadcn/ui** (`Form`, `FormField`, `FormItem`, `FormLabel`, `FormControl`, `FormMessage`, `Input`, `Button`) para padronização.

## Exemplo: Formulário de Login
```
"use client";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

const loginSchema = z.object({
  email: z.string().email({ message: "Email inválido" }),
  password: z.string().min(6, { message: "Senha mínima de 6 caracteres" }),
});

type LoginFormValues = z.infer<typeof loginSchema>;

export function LoginForm() {
  const form = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: { email: "", password: "" },
  });

  const onSubmit = (values: LoginFormValues) => {
    console.log("Login:", values);
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input {...field} placeholder="Digite seu email" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="password"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Senha</FormLabel>
              <FormControl>
                <Input type="password" {...field} placeholder="Digite sua senha" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit">Entrar</Button>
      </form>
    </Form>
  );
}
```

# Cards Reutilizáveis
```
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";

export function InfoCard({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <Card className="bg-white dark:bg-gray-800 shadow-md rounded-lg">
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>{children}</CardContent>
    </Card>
  );
}
```

# Modals com shadcn/ui
```
import { Dialog, DialogTrigger, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogClose } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

export function ConfirmModal({ title, description, onConfirm }: { title: string; description: string; onConfirm: () => void }) {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button>Abrir Modal</Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
          <DialogDescription>{description}</DialogDescription>
        </DialogHeader>
        <div className="flex justify-end mt-4 gap-2">
          <Button variant="outline" onClick={() => {}}>Cancelar</Button>
          <Button onClick={onConfirm}>Confirmar</Button>
        </div>
        <DialogClose />
      </DialogContent>
    </Dialog>
  );
}
```

# Uso de Ícones com lucide-react
- Todos os ícones devem vir de **lucide-react**.
- Evitar SVGs inline ou outras bibliotecas.
- Importar ícones de forma específica:
```
import { Home, User, Trash } from "lucide-react";
```
- Usar em componentes do shadcn/ui ou botões, inputs, menus.
- Exemplo de botão com ícone:
```
import { Button } from "@/components/ui/button";
import { Trash } from "lucide-react";

<Button variant="destructive" size="sm">
  <Trash className="mr-2 h-4 w-4" />
  Excluir
</Button>
```
- Manter consistência de tamanho, cor e estilo em todos os ícones.

# API Routes & Server Actions
- Usar Zod para validar entrada e saída.
- Tipar retorno e erros.
```
import { z } from "zod";
import type { NextRequest, NextResponse } from "next/server";

const loginSchema = z.object({ email: z.string().email(), password: z.string() });

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const data = loginSchema.parse(body);
    return NextResponse.json({ success: true, data });
  } catch (err) {
    return NextResponse.json({ success: false, error: err }, { status: 400 });
  }
}
```

# Extras Next.js
- next/image, next/font
- Dynamic imports
- Prefetch automático com Link
- Server Components para fetch
- Client Components apenas para interação

# Observações Finais
- Priorizar Server Components.
- Validar todos os dados com Zod.
- Seguir rigorosamente shadcn/ui.
- Componentes reutilizáveis.
- Formulários sempre com React Hook Form + Zod.
- Ícones sempre com lucide-react.
